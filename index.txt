Unit 2: Stack

Stack – Introduction & Basics
	1.	Introduction to Stack
	•	Definition of Stack
	•	Real-life examples of Stack (LIFO principle: Last In First Out)
	•	Applications of Stack
	2.	Stack as an Abstract Data Type (ADT)
	•	Concept of ADT
	•	Representation of Stack as ADT
	•	Characteristics & constraints

⸻

Stack Operations
	3.	Basic Operations on Stack
	•	Push (Insertion)
	•	Pop (Deletion)
	•	Peek/Top (Access element)
	•	isEmpty / isFull (Status checks)

⸻

Implementation of Stack
	4.	Array Implementation of Stack
	•	Using static arrays
	•	Drawbacks & limitations
	5.	Multiple Stacks
	•	Concept of storing more than one stack in a single array
	•	Memory optimization

⸻

Applications of Stack
	6.	Evaluation of Arithmetic Expressions
	•	Infix, Prefix, Postfix expressions
	•	Conversion between expressions
	•	Evaluation using stack



Unit 3: Queue

1. Introduction to Queue
	•	Definition of Queue
	•	Characteristics of Queue (FIFO principle)
	•	Real-life examples of Queue
	•	Comparison with Stack

⸻

2. Abstract Data Type (ADT) of Queue
	•	ADT definition for Queue
	•	Queue operations:
	•	enqueue() – Insert element
	•	dequeue() – Delete element
	•	peek()/front() – Access first element
	•	isEmpty() – Check if queue is empty
	•	isFull() – Check if queue is full

⸻

3. Array Implementation of Queue
	•	Representation of Queue using Array
	•	Limitations of Simple Array Queue
	•	Overflow & Underflow conditions
	•	Example Programs

⸻

4. Types of Queues

4.1 Circular Queue
	•	Concept and Need for Circular Queue
	•	Implementation using Arrays
	•	Operations (enqueue, dequeue) in Circular Queue
	•	Advantages over Linear Queue

4.2 Priority Queue
	•	Introduction to Priority Queue
	•	Types of Priority Queue:
	•	Ascending Priority Queue
	•	Descending Priority Queue
	•	Applications of Priority Queue

4.3 Double Ended Queue (Deque)
	•	Definition of Deque
	•	Types:
	•	Input-restricted Deque
	•	Output-restricted Deque
	•	Operations on Deque

4.4 Multiple Queues
	•	Concept of Multiple Queues
	•	Need and Applications (e.g., CPU scheduling, Printer queue)
	•	Implementation approaches

Unit 4: Linked List

⸻

1. Introduction to Linked Lists
	•	Definition of Linked List
	•	Characteristics of Linked Lists
	•	Comparison: Linked List vs Array
	•	Real-life Examples of Linked Lists

⸻

2. Types of Linked Lists
	•	Singly Linked List
	•	Doubly Linked List
	•	Circular Linked List

⸻

3. Operations on Linked Lists

3.1 Singly Linked List
	•	Insertion:
	•	At Beginning
	•	At End
	•	At Specific Position
	•	Deletion:
	•	From Beginning
	•	From End
	•	From Specific Position
	•	Update Operation
	•	Copying a Singly Linked List

3.2 Doubly Linked List
	•	Insertion:
	•	At Beginning
	•	At End
	•	At Specific Position
	•	Deletion:
	•	From Beginning
	•	From End
	•	From Specific Position
	•	Update Operation
	•	Copying a Doubly Linked List

⸻

4. Applications of Linked Lists
	•	Implementation of Stack using Linked List
	•	Implementation of Queue using Linked List

⸻

5. Advanced Operation
	•	Reversing a Singly Linked List


https://www.geeksforgeeks.org/dsa/types-of-linked-list/


Unit 5: Trees

⸻

1. Introduction to Trees
	•	Definition of Tree
	•	Hierarchical structure and properties
	•	Real-life examples of Tree (family tree, file system, organization hierarchy)
	•	Applications of Trees

⸻

2. Tree Terminologies
	•	Root, Parent, Child
	•	Leaf, Sibling, Ancestor, Descendant
	•	Degree of Node, Degree of Tree
	•	Depth, Height, Level, Path
	•	Subtree

⸻

3. Binary Tree
	•	Definition of Binary Tree
	•	Properties of Binary Tree
	•	Binary Tree Representations
	•	Linked Representation
	•	Array Representation

⸻

4. Types of Binary Tree
	•	Full Binary Tree
	•	Complete Binary Tree
	•	Perfect Binary Tree
	•	Balanced Binary Tree
	•	Skewed Binary Tree (Left/Right)

⸻

5. Binary Tree Traversals
	•	Depth-First Traversals
	•	Inorder (L → Root → R)
	•	Preorder (Root → L → R)
	•	Postorder (L → R → Root)
	•	Breadth-First Traversal (Level-order Traversal)

⸻

6. Binary Search Tree (BST)
	•	Definition and Properties
	•	Applications of BST

6.1 Operations on BST
	•	Insertion of a Node
	•	Searching for a Node
	•	Deletion of a Node (3 cases: leaf, one child, two children)